#include <stdlib.h>
#include <stdio.h>

unsigned long HW_HOST_LL2(int reg) {
}

void write_data(unsigned int c);
unsigned char read_data(void);

#pragma pack(1)
#define debug(a) printf a

#if BLOCK_SIZE == 256
#define MAX_SECTOR  17
#else
#define MAX_SECTOR  8
#endif

unsigned int DISK_SR = 0;
unsigned int DISK_CR = 0;
unsigned int DISK_DATA = 0;

#define HW_DISK_SR_R() DISK_SR
#define HW_DISK_CR_W(d) DISK_CR = d
// #define HW_DISK_DATA_R() DISK_DATA
// #define HW_DISK_DATA_W(d) DISK_DATA = d
#define HW_DISK_DATA_W(d) write_data(d)
#define HW_DISK_DATA_R() read_data()

void OSD_Puts(char *s);
//#include "../swap.c"

void OSD_ProgressBar(int n, int m) {
  printf("OSD_ProgressBar: %d / %d\n", n, m);
}

unsigned char diskbuff[512*1024];

void MEM_write(unsigned long address, unsigned char data) {
  // printf("MEM_write(%08X, %02X)\n", address, data);
  diskbuff[address] = data;
}

unsigned char MEM_read(unsigned long address) {
  // printf("MEM_read(%08X) returns %02X\n", address, diskbuff[address]);
  return diskbuff[address];
}

#include "../misc.c"
#include "../minfat.c"
#define UNDER_TEST
#include "../disk.c"
#include "../storage.c"

#define WRITECOPY
#include "common.h"

typedef void (*handler_t)(void);

static handler_t handlers[IRQ_MAX] = {0};

void SetIntHandler(int irq, void (*new_handler)()) {
  handlers[irq] = new_handler;
}

/************************************************************************************/
void testDiskInit(void) {
  passif(DirCd("zx"), "cd zx");
  passif(DirCd("disks"), "cd disks");

  passifeq(handlers[IRQ_DISK], NULL, "no ISR installed");
  DiskInit();
}

void diskhandler() {
  // read from CR -> write to SR
}


unsigned char sector0[] = {
  0x18, 0x05, 0x28, 0x12, 0x40, 0x4a, 0x0b, 0x7e, 0xdd, 0x77, 0x00, 0x23, 0x7e, 0xdd, 0x77, 0x01,
  0xdd, 0x7e, 0x02, 0xe6, 0x2f, 0x57, 0x23, 0x7e, 0xe6, 0xd0, 0xb2, 0xdd, 0x77, 0x02, 0xc9, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x40, 0xe5, 0x01, 0xf7, 0x18, 0x4e, 0x0c, 0x00, 0x03, 0xf5, 0x01, 0xfe, 0x01, 0x27, 0x01, 0x00,
  0x01, 0x07, 0x01, 0x01, 0x01, 0xf7, 0x16, 0x4e, 0x0c, 0x00, 0x03, 0xf5, 0x01, 0xfb, 0x40, 0xe5,
  0x40, 0xe5, 0x40, 0xe5, 0x40, 0xe5, 0x01, 0xf7, 0x18, 0x4e, 0x0c, 0x00, 0x03, 0xf5, 0x01, 0xfe,
  0x01, 0x27, 0x01, 0x00, 0x01, 0x0e, 0x01, 0x01, 0x01, 0xf7, 0x16, 0x4e, 0x0c, 0x00, 0x03, 0xf5,
  0x01, 0xfb, 0x40, 0xe5, 0x40, 0xe5, 0x40, 0xe5, 0x40, 0xe5, 0x01, 0xf7, 0x18, 0x4e, 0x0c, 0x00,
  0x03, 0xf5, 0x01, 0xfe, 0x01, 0x27, 0x01, 0x00, 0x01, 0x03, 0x01, 0x01, 0x01, 0xf7, 0x16, 0x4e,
  0x0c, 0x00, 0x03, 0xf5, 0x01, 0xfb, 0x40, 0xe5, 0x40, 0xe5, 0x40, 0xe5, 0x40, 0xe5, 0x01, 0xf7,
  0x18, 0x4e, 0x0c, 0x00, 0x03, 0xf5, 0x01, 0xfe, 0x01, 0x27, 0x01, 0x00, 0x01, 0x0a, 0x01, 0x01,
#if BLOCK_SIZE == 512
  0xff, 0x00, 0x00, 0x00, 0x06, 0x00, 0x44, 0x49, 0x53, 0x43, 0x20, 0x31, 0x20, 0x20, 0x20, 0x20,
  0xce, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x41, 0x64, 0x76, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x20,
  0x52, 0x00, 0x08, 0x00, 0x08, 0x00, 0x72, 0x75, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x81, 0x00, 0x09, 0x00, 0x17, 0x00, 0x6c, 0x6f, 0x67, 0x6f, 0x31, 0x20, 0x20, 0x20, 0x20, 0x20,
  0xc6, 0x00, 0x18, 0x00, 0x1b, 0x00, 0x43, 0x6f, 0x6d, 0x70, 0x61, 0x6e, 0x2e, 0x74, 0x78, 0x74,
  0x06, 0x00, 0x1c, 0x00, 0x26, 0x00, 0x4f, 0x70, 0x75, 0x73, 0x76, 0x31, 0x2e, 0x74, 0x78, 0x74,
  0x06, 0x00, 0x27, 0x00, 0x2b, 0x00, 0x45, 0x78, 0x74, 0x72, 0x69, 0x63, 0x2e, 0x74, 0x78, 0x74,
  0x86, 0x00, 0x2c, 0x00, 0x67, 0x00, 0x44, 0x69, 0x73, 0x63, 0x45, 0x64, 0x2e, 0x74, 0x78, 0x74,
  0x86, 0x00, 0x68, 0x00, 0x7e, 0x00, 0x53, 0x2e, 0x44, 0x75, 0x6d, 0x70, 0x2e, 0x74, 0x78, 0x74,
  0x46, 0x00, 0x7f, 0x00, 0x81, 0x00, 0x4d, 0x2f, 0x66, 0x61, 0x63, 0x65, 0x2e, 0x74, 0x78, 0x74,
  0x86, 0x00, 0x82, 0x00, 0x86, 0x00, 0x43, 0x6f, 0x70, 0x69, 0x65, 0x72, 0x2e, 0x74, 0x78, 0x74,
  0xc6, 0x00, 0x87, 0x00, 0x8b, 0x00, 0x45, 0x6e, 0x64, 0x75, 0x72, 0x6f, 0x2e, 0x74, 0x78, 0x74,
  0xc6, 0x00, 0x8c, 0x00, 0x90, 0x00, 0x51, 0x75, 0x61, 0x7a, 0x61, 0x74, 0x2e, 0x74, 0x78, 0x74,
  0x46, 0x00, 0x91, 0x00, 0x9b, 0x00, 0x45, 0x73, 0x63, 0x61, 0x70, 0x65, 0x2e, 0x74, 0x78, 0x74,
  0xc6, 0x00, 0x9c, 0x00, 0xa0, 0x00, 0x53, 0x70, 0x65, 0x65, 0x64, 0x20, 0x2e, 0x74, 0x78, 0x74,
  0x8e, 0x00, 0xa1, 0x00, 0xaa, 0x00, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x6e, 0x64, 0x65, 0x72, 0x20
#endif
};

/************************************************************************************/
unsigned char buffer[512];
unsigned char buffer2[512];

unsigned char read_data(void) {

}

int wpos = 0;
void write_data(unsigned int c) {
  buffer[wpos] = c & 0xff;
  if (c & 0x100) {
    wpos ++;
  }
}

void read_sector(int disk, int sector) {
  DISK_SR = (disk ? HW_DISK_READSECTOR1 : HW_DISK_READSECTOR0) | sector;
  handlers[IRQ_DISK]();
  DiskHandler();
}

void update_disk(int flags, int sector) {
  DISK_SR = flags | sector;
  handlers[IRQ_DISK]();
  DiskHandler();
}

// void read_data(int disk, unsigned char *buffer, int n) {
//   DISK_SR = disk ? HW_DISK_READDATA1 : HW_DISK_READDATA0;
//   for (int i=0; i<n; i++) {
//     handlers[IRQ_DISK]();
//     buffer[i] = disk ? DISK_DATA1 : DISK_DATA0;
//   }
// }

int isBlank(unsigned char *buffer) {
  int i;
  for (i=0; i<BLOCK_SIZE; i++) {
    if (buffer[i] != 0xe5) break;
  }
  return i==BLOCK_SIZE;
}


void testHappyPath(int disk) {
  // int ack = (disk ? HW_DISK_CR_ACK1 : HW_DISK_CR_ACK0);
  // int fin = (disk ? HW_DISK_CR_FIN1 : HW_DISK_CR_FIN0);
  passifeq(handlers[IRQ_DISK], DiskISR, "ISR installed");
  passif(!diskIsInserted[disk], "no disk inserted");
  passif(DiskOpen(disk, "SDCLD01.OPD"), "open actual disk");
  passif(diskIsInserted[disk], "disk inserted");

  // read sector
  wpos = 0;
  read_sector(disk, STS(0,0,0));
  passifeq(DISK_CR, HW_DISK_CR_SACK, "expecting ack");
  passifeq(wpos, BLOCK_SIZE, "expecting data");

  // DISK_SR = disk ? HW_DISK_READDATA1 : HW_DISK_READDATA0;
  // handlers[IRQ_DISK]();
  // passifeq(disk ? DISK_DATA1 : DISK_DATA0, sector0[0], "read first byte");
  // passifeq(DISK_CR, ack, "expecting ack");
  // buffer[0] = disk ? DISK_DATA1 : DISK_DATA0;
  //
  // read_data(disk, buffer+1, BLOCK_SIZE-1);

  // passif(DISK_CR == (ack|fin), "expecting ack and fin");
  passif(!memcmp(buffer, sector0, BLOCK_SIZE), "first sector compares ok");

  passifeq(STS_TO_BLOCK(0,39,MAX_SECTOR), 359, "check block calculation");
  wpos = 0;
  read_sector(disk, STS(0,39,MAX_SECTOR));
  // read_data(disk, buffer, BLOCK_SIZE);
  // read sector
  update_disk(0, STS(0,39,MAX_SECTOR));
  passifeq(DISK_CR, 0, "expecting clear");
  passif(isBlank(buffer), "last sector compares ok");
}

#if 0
void testOverlappedRead(void) {
  read_sector(0, STS(0,0,0));
  read_sector(1, STS(0,39,MAX_SECTOR));

  read_data(0,buffer2,128);
  read_data(1,buffer,128);
  read_data(0,buffer2+128,256);
  read_data(1,buffer+128,128);
  read_data(0,buffer2+128+256,128);
  read_data(1,buffer+128+128,256);

  passif(!memcmp(buffer2, sector0, BLOCK_SIZE), "sector 0 reads ok");
  passif(isBlank(buffer), "sector 359 reads ok");
}

void testOverlappedRead2(void) {
  read_sector(0, STS(0,39,MAX_SECTOR));
  read_sector(1, STS(0,0,0));

  DISK_SR = HW_DISK_READDATA1 | HW_DISK_READDATA0;

  handlers[IRQ_DISK]();
  buffer[0] = DISK_DATA0;
  buffer2[0] = DISK_DATA1;
  passif(DISK_CR == (HW_DISK_CR_ACK1|HW_DISK_CR_ACK0), "both interfaces acked");

  for (int i=1; i<BLOCK_SIZE; i++) {
    handlers[IRQ_DISK]();
    buffer[i] = DISK_DATA0;
    buffer2[i] = DISK_DATA1;
  }
  // printf("DISK_CR = %08X\n", DISK_SR);
  passif(DISK_CR == (HW_DISK_CR_ACK1|HW_DISK_CR_ACK0|HW_DISK_CR_FIN1|HW_DISK_CR_FIN0), "both interfaces acked and finned");

  passif(!memcmp(buffer2, sector0, BLOCK_SIZE), "sector 0 reads ok");
  passif(isBlank(buffer), "sector 359 reads ok");
}
#endif
//TODO: disk menus - increased memory
//TODO: add file offset finding
//TODO: add disk logic interface

//TODO: check emulation matches zpu specifics
//TODO: rom menus
//TODO: cleanup files
//TODO: Firmware size reduction somehow
//TODO: should not open file dialog

#define test(a,b) fprintf(stderr, "-----------------\nTESTING " # a "\n-----------------\n"); printf("-----------------\nTESTING " # a "\n-----------------\n"); test##a b

int main(int argc, char **argv) {
  openCard();

  passif(FindDrive(), "open disk");

  test(DiskInit,());
  test(HappyPath,(0));
  test(HappyPath,(1));
  // test(OverlappedRead,());
  // test(OverlappedRead2,());
  passifeq(STS_TO_BLOCK(0,39,MAX_SECTOR), 359, "check block calculation");

  closeCard();
  info();
  return tests_run - tests_passed;
}
